<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <video id="outputVideo" autoplay muted></video>
</body>
<script>
    let outputVideo = document.querySelector('#outputVideo');
    let rtc = new RTCPeerConnection();

    let mungeSDPOffer = function (offer) {

        let audioSDP = '';

        // set max bitrate to highest bitrate Opus supports
        audioSDP += 'maxaveragebitrate=510000;';

        if (self.useMic) {
            // set the max capture rate to 48khz (so we can send high quality audio from mic)
            audioSDP += 'sprop-maxcapturerate=48000;';
        }

        // Force mono or stereo based on whether ?forceMono was passed or not
        audioSDP += self.forceMonoAudio ? 'sprop-stereo=0;stereo=0;' : 'sprop-stereo=1;stereo=1;';

        // enable in-band forward error correction for opus audio
        audioSDP += 'useinbandfec=1';

        // We use the line 'useinbandfec=1' (which Opus uses) to set our Opus specific audio parameters.
        offer.sdp = offer.sdp.replace('useinbandfec=1', audioSDP);
    }

    let setupTransceiversAsync = async function(pc){
        
        let hasTransceivers = pc.getTransceivers().length > 0;

        // Setup a transceiver for getting UE video
        pc.addTransceiver("video", { direction: "recvonly" });

        // Setup a transceiver for sending mic audio to UE and receiving audio from UE
        if(!self.useMic)
        {
            pc.addTransceiver("audio", { direction: "recvonly" });
        }
        else
        {
            let audioSendOptions = self.useMic ? 
            {
                autoGainControl: false,
                channelCount: 1,
                echoCancellation: false,
                latency: 0,
                noiseSuppression: false,
                sampleRate: 48000,
                volume: 1.0
            } : false;

            // Note using mic on android chrome requires SSL or chrome://flags/ "unsafely-treat-insecure-origin-as-secure"
            const stream = await navigator.mediaDevices.getUserMedia({video: false, audio: audioSendOptions});
            if(stream)
            {
                if(hasTransceivers){
                    for(let transceiver of pc.getTransceivers()){
                        if(transceiver && transceiver.receiver && transceiver.receiver.track && transceiver.receiver.track.kind === "audio")
                        {
                            for (const track of stream.getTracks()) {
                                if(track.kind && track.kind == "audio")
                                {
                                    transceiver.sender.replaceTrack(track);
                                    transceiver.direction = "sendrecv";
                                }
                            }
                        }
                    }
                }
                else
                {
                    for (const track of stream.getTracks()) {
                        if(track.kind && track.kind == "audio")
                        {
                            pc.addTransceiver(track, { direction: "sendrecv" });
                        }
                    }
                }
            }
            else
            {
                pc.addTransceiver("audio", { direction: "recvonly" });
            }
        }
    };
    let socket = new WebSocket("ws://127.0.0.1:80");
    socket.onopen = () => {
        //socket.send(JSON.stringify({ type: "viewer" }));
    };
    socket.onmessage = async (event) => {
        let data = JSON.parse(event.data);
        try {
            if (data.type === "offer") {
                await rtc.setRemoteDescription(new RTCSessionDescription(data));
                setupTransceiversAsync(rtc).finally(function(){
                    rtc.createAnswer().then(answer=>{
                    mungeSDPOffer(answer);
                    return rtc.setLocalDescription(answer);
                }).then(()=>{
                    socket.send(JSON.stringify(rtc.currentLocalDescription));
                });
                })
                
            } else if (data.type === "iceCandidate" && data.candidate) {
                await rtc.addIceCandidate(new RTCIceCandidate(data.candidate));
            } else {
                console.log("unknown message:", data);
            }
        } catch (error) {
            console.error("Failed to handle message:", error);
        }
    };


    rtc.ontrack = async (event) => {
        console.log('Received track:', event.track.kind);
        if(event.track.kind == "video"){

            outputVideo.srcObject = event.streams[0];

            // All tracks are added "muted" by WebRTC/browser and become unmuted when media is being sent
            event.track.onunmute = () => {
                outputVideo.srcObject = event.streams[0];
            }
        }
        //outputVideo.srcObject = event.streams[0];
        console.log('Stream tracks:', event.streams[0].getTracks());
    };

    rtc.onicecandidate = (event) => {
        if (event.candidate) {
            socket.send(JSON.stringify({ type: 'iceCandidate', candidate: event.candidate }));
        }
    };

    rtc.oniceconnectionstatechange = function () {
        console.log('ICE state: ', rtc.iceConnectionState);
        if (rtc.iceConnectionState === 'failed' || rtc.iceConnectionState === 'disconnected' || rtc.iceConnectionState === 'closed') {
            console.error('ICE state indicate failure');
        }
    };

    rtc.onsignalingstatechange = function () {
        console.log('Signaling state: ', rtc.signalingState);
    };
    outputVideo.onplay = () => {
        console.log('Video is now playing.');
    };
    outputVideo.onloadeddata = () => {
        console.log('Video data has loaded.');
    };


</script>

</html>